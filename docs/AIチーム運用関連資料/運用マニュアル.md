# AIチーム協業 運用マニュアル (v1.4)

目的 本マニュアルは、AI（SC, RV-G, RV-C, GH, CM, AI-C, AI-Cl, RV-CG-QA, RV-GM-SEC, RV-CL-MAINT, RV-CP-PERF）との協業において、過去の教訓を活かし、「認識のズレ」によるエラーや手戻りを最小限に抑え、効率的かつ高品質な開発を実現するための運用指針を定める。特に、AIの特性を踏まえたリスクマネジメントとコミュニケーションの最適化に焦点を当てる。
##各フェーズにおける運用ルールと担当
## 1. プロジェクト開始・計画フェーズ
いつ: プロジェクト開始時、または新規タスク着手前  
だれが: ME、CM  
何を:
- プロジェクト全体の**「大義」（目的・品質目標・テスト戦略）**を明確にする。
- 新規追加または大幅に改修されるコードに対する単体テストコードの作成を必須とすること。
- AIチーム制の各AIの役割と期待値を再確認。
- このフェーズで、タスク全体のテスト戦略を策定する（どのテストレベルを実施するか、品質目標、責任範囲など）。 どのように:
- MEが、プロジェクトの背景、最終的な品質目標、優先順位（例：「安定性最優先」「メンテナンス性重視」）といった戦略的情報に加え、**単体テストの必要性やそのスコープ（例：新規クラス・メソッドのカバレッジ目標など）**をAI全体に共有する。
- CMが、JSTQB ALTMの観点からプロセス改善の視点を提供する。 
どうする: AIが単なるタスク実行者ではなく、プロジェクトの目標を理解した上で最適な判断ができる基盤を築く。
## 2. 詳細設計フェーズ
いつ: コーディング着手前  
だれが: ME、SC  
何を:
- 具体的な変更内容を記述した詳細設計書を作成。
- AIが誤って変更しないように明確な制約を指示。
- SCに変更インパクトの予測を要求。
- 新規に追加されるファイルや大規模に改修されるコンポーネントについては、その単体テストコードの設計方針（例：JUnitの使用、モックの利用、主要なテストケースやテストデータの検討など）を明確にする。
- 設計段階で、コンポーネントの**「テスト容易性（Testability）」**を考慮し、テストしやすい構造になっているかを確認する。  
どのように:
- 詳細設計書に以下のセクションを必ず追加する。
- 【AIへの指示】: 「指示された変更点以外にも変更が必要とSCが判断した場合は、具体的な変更点の詳細を明記してMEに『質問返し』してください。その中で変更NG箇所がある場合は、MEが【NO_TOUCHリスト】（変更禁止領域の具体的リスト）を作成し、変更NG箇所を明確にします。なお上記で明記しなかった箇所には一切変更を加えないでください。また、新規追加または大規模に改修されるコンポーネントについては、その単体テストの実施方法、テストケースの概要、テストデータに関する考察を詳細設計に含めてください。」と明記する。
- 【変更の粒度指示】: 「デフォルトでは小刻みな変更を原則とする。密結合で小刻みな変更が困難で一括改修が必要と判断される場合は、SCからMEに事前に相談を返してください。」と明記。
- 【変更インパクト予測】: 「この詳細設計に基づくと、既存コードのどの部分が、どの程度の規模で変更される可能性があるかを予測し、設計書に追記してください。」とSCに指示する。 
どうする: AIへの指示を極めて明確にし、意図しない変更のリスクを設計段階で最小化する。MEは変更インパクトを事前に把握し、設計の妥当性を評価する。
## 3. 詳細設計レビューフェーズ
いつ: 詳細設計書完成後、コーディング着手前  
だれが: ME、RV-G、RV-C (その他レビュー系AI)  
何を:
- 詳細設計書の妥当性、特にAIへの指示の明確性と網羅性をレビュー。
- SCの変更インパクト予測を確認。  
どのように:
- RV-G、RV-Cは、設計書の内容だけでなく、**「AIが誤解釈する可能性のある箇所」「既存コードとの整合性」**の視点も加えてレビューする。
- 【AIによる質問返し】: レビュアーAIは、設計に不明点や疑義がある場合、また「AIへの指示」関連の懸念がある場合、能動的にMEに確認を返す。
- 【MEによる重点レビュー】: MEは、詳細設計の以下の点を特に注視してレビューする。
- 「AIへの指示」の内容と、その網羅性、不変性指示の明確性。
- SCの「変更インパクト予測」の妥当性。
- AIからの質問返しに対するMEの判断基準と承認プロセスを確立する。  
どうする: 設計段階で潜在的な「認識のズレ」を洗い出し、後の手戻りを予防する。
## 4. コード生成・コードレビューフェーズ
いつ: 詳細設計承認後  
だれが: SC（生成）、ME、RV-G、RV-C (その他レビュー系AI)  
何を:
- 設計に基づいたコード生成。
- 生成されたコードの品質と、既存コードとの整合性レビュー。 どのように:
- 【SCによるコード生成】: SCは、詳細設計の指示（特に「変更しない領域」）を厳守してコードを生成する。
- 【AIレビュアーによる評価】:
- RV-G、RV-Cは、コードの機能要件達成度、品質に加え、**「既存コードとの適合性」「変更の影響範囲」**を重視してレビューする。
- もしRV-G、RV-Cが**「簡潔化」「リファクタリング」を過度に「絶賛」した場合は、そのレビュー結果に「破壊的変更リスクあり」の警告フラグ**を付与し、MEへの報告を必須とする。
- 【MEによる最終差分チェック】:
- MEは、SCが生成したコードの差分（diff）を必ず厳密に確認する。特に、警告フラグが立った箇所や、環境依存部分（パス、ファイル名、既存ヘルパーメソッド）に意図しない変更がないかを重点的にレビューする。
- 【推奨（学習プランで検討・導入）】静的解析ツールの活用: CMからの学習プランに基づき、LinterやSonarQubeなどの静的解析ツールを導入し、SCが生成したコードの初期品質を自動的にチェックし、MEのレビュー負荷を軽減する。 どうする: コードの品質を確保し、AIによる意図しない変更を最終段階で検知・修正する。
## 5. テスト・トラブルシューティングフェーズ
いつ: コードレビュー承認後  
だれが: ME、SC、RV-G、RV-C  
何を: コードの機能テスト、バグ修正。  
どのように:
- 【エラー連発時の迅速な対応】: テスト実行中にエラーが連鎖的に発生し、根本原因の特定に時間を要すると判断した場合、漫然とデバッグを続けるのではなく、速やかに安定版へのロールバック（変更破棄）を優先する。
- 【エラー発生時の詳細対応フロー】:
- 初期検知とSCへの相談（ME→SC）: MEはエラーを検知したら、まずSCに状況を報告し、SCはMEにエラー内容の提供などの協力を仰ぎながらMEと共に根本原因を調査する。
- 修正方針の提案（SC→ME）: SCはMEと共に調査した根本原因に基づき、複数の修正方針（例：A案、B案）を提示する。各方針のメリット・デメリット、影響範囲、推定リスクをMEに説明する。
- 修正方針のレビューと選択、中断条件の明確化（ME、RV-G、RV-C→SC）: MEはSCから提示された修正方針をレビューし、最適な方針を選択する。RV-G、RV-Cもこの修正方針のレビューに参加する。この際、各方針において「何が達成できなかったら修正を中断するか」を明確に定義し、SCに伝える。
- 具体的な修正案の提案（SC→ME）: 選択された修正方針に基づき、SCが具体的なコード修正案（diff形式など）をMEに提示する。
- 具体的な修正案のレビュー（ME、RV-G、RV-C）: MEはSCから提示された具体的な修正案をレビューし、品質、正確性、副作用の有無を確認する。RV-G、RV-Cもこの具体的な修正案のレビューに参加する。
- 修正の実行（SC）: レビュー承認された修正案をSCが実行する。  
どうする: プロジェクトの停滞を防ぎ、リスクとコストの増大を抑制しつつ、効率的に問題解決を図る。
## 6. 継続的改善フェーズ
いつ: 各タスク完了後、または定期的  
だれが: ME、CM  
何を:
- 各フェーズの運用実績を振り返り、課題と改善点を特定する。
- 本マニュアルのルールを適宜見直し、更新する。 どのように:
- 定期的にMEが実施する**「振り返り（レトロスペクティブ）」**で、CMがJSTQB ALTMの観点からプロセスやツールの有効性を評価する。
- 【AIからの自律報告】: タスク終了後に、MEが実施する振り返りで「タスク完了報告をお願いします」と促したら、各AIは自律的に結果を報告する。
- このマニュアルを「生きているドキュメント」として、常に見直し、最適化を図る。  
どうする: AIとの協業プロセスそのものを継続的に改善し、将来的なプロジェクトの効率と品質を向上させる。
